func real Kappate(int modeNumber, real size1, real size2)
{
	return kappas[abs(modeNumber)-1]/size1;
}
func complex anEte(real xx, real yy, int modeNumber, int M, int componentNumber, real size1, real size2, real k) 
{
	real kp = Kappate(modeNumber, size1, 0);
	real h = H(k, kp);
	real sign = 0; if(modeNumber >= 0) sign = 1.; else sign = -1.;
	real rho = kp*yy;
	real mu = kp*size1;
	//cout << kp << "," << h << "," << rho << endl;
	if(componentNumber == 2){ //r
	   //   if(yy == 0) 
		//  	if(M != 1) return 0;		    
		//      else return k*M*exp(1i*h*xx*sign)*0.5*mu/size1*exp(1i*h*xx*sign);
	    return k*M*jn(M, rho)*exp(1i*h*xx*sign)/yy;
	}
	if(componentNumber == 3){//phi	
	    real jnDash = 0.5*(jn(M-1, rho) - jn(M+1, rho));		
		return 1i*k*mu*(jnDash)*exp(1i*h*xx*sign)/size1;
	}
	return 0*1i;
}

func complex anHte(real xx, real yy, int modeNumber, int M,  int componentNumber, real size1, real size2, real k) //m - radial index, M - axial index
{
	real kp = Kappate(abs(modeNumber), size1, 0);
	real h = H(k, kp);
	real sign = 0; if(modeNumber >= 0) sign = 1.; else sign = -1.;
	real rho = kp*yy;
	real mu = kp*size1;
	if(componentNumber == 3){//phi
	   // if(yy == 0)
		//	if( M!= 1) return 0;
	   //     else return h*M*sign*0.5*kp/size1*exp(1i*h*xx*sign);
		return h*M*sign*jn(M, rho)*exp(1i*h*xx*sign)/yy;
	}
	if(componentNumber == 2){//r
	    real jnDash = 0.5*(jn(M-1, rho) - jn(M+1, rho));
		return -1i*h*sign*mu*jnDash/size1*exp(1i*h*xx*sign);
	}
	if(componentNumber == 1){//z
	    return  (-k*k + h*h)*jn(M, rho)*exp(1i*h*xx*sign);
	}	
	return 0*1i;
}

func real fNormte(int modeNumber, real size1, real k)
{
	real kp = Kappate(modeNumber, size1, 0);
	real h = H(k, kp);
	return  4.*pi*h*k*norma[abs(modeNumber)-1];
}